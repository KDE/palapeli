/***************************************************************************
 *   Copyright (C) 2008 Stefan Majewsky <majewsky@gmx.net>
 *
 *   This program is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU General Public
 *   License as published by the Free Software Foundation; either
 *   version 2 of the License, or (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 ***************************************************************************/

#ifndef PALAPELI_PATTERN_H
#define PALAPELI_PATTERN_H

#if defined(MAKE_LIBPALAPELIPATTERN)
 #include "macros.h"
#else
 #include <Palapeli/Macros>
#endif

class QImage;
#include <QList>
#include <QObject>
class QPointF;
class QRectF;

//TODO: signals for progress reporting
//TODO: remove positionDifference in addRelation function
//TODO: add \since command once we move to kdegames

namespace Palapeli
{

	class PatternPrivate;

	/**
	 * \class Pattern pattern.h Palapeli/Pattern
	 * \short Slicing implementation in Palapeli pattern plugins.
	 *
	 * This class is used in a Palapeli pattern plugin to provide the actual slicing implementation. Its configuration is generated by the Palapeli::PatternConfiguration subclass contained in the plugin.
	 *
	 * To create your sub-class of Palapeli::Pattern, you will need to implement the slice function. This function can call the addPiece and addRelation functions to add pieces to the puzzle scene, and add neighbor relations between them. The following example illustrates a pattern which splits the base image into two equally sized parts:
	 \code
class MyPattern : public Palapeli::Pattern {

//implement public constructor and public and virtual destructor here

protected:
	virtual void slice(const QImage& image) {
		//construct pixmaps for the pieces
		const int pieceWidth = image.width() / 2, pieceHeight = image.height();
		QPixmap leftPiecePixmap = QPixmap::fromImage(image.copy(QRect(0, 0, pieceWidth, pieceHeight)));
		QPixmap rightPiecePixmap = QPixmap::fromImage(image.copy(QRect(pieceWidth, 0, pieceWidth, pieceHeight)));
		//add pieces; define a neighborship relation between them
		addPiece(leftPiecePixmap, QRectF(0, 0, pieceWidth, pieceHeight));
		addPiece(rightPiecePixmap, QRectF(pieceWidth, 0, pieceWidth, pieceHeight));
		addRelation(0, 1, QPointF(pieceWidth, 0)); //0 and 1 are the consecutive indices of the pieces
	};

};
	 \endcode
	 *
	 * \author Stefan Majewsky <majewsky@gmx.net>
	 */
	class PALAPELIPATTERN_EXPORT Pattern : public QObject
	{
		Q_OBJECT
		public:
			/**
			 * \brief Constructs a new pattern object.
			 * This base constructor is currently unused; you should implement it to get configuration values from your Palapeli::PatternConfiguration object.
			 */
			Pattern();
			/**
			 * \brief Destructor.
			 */
			virtual ~Pattern();

			/**
			 * \brief For internal use only.
			 * The Palapeli game engine will call this function if a game is loaded from the storage, in order to give the previous piece positions to the pattern. The base class will handle this process automatically as you create the pieces.
			 */
			void loadPiecePositions(const QList<QPointF>& points);
			/**
			 * \brief For internal use only.
			 * The Palapeli game engine will call this function to create pieces from a given \a image. You will not need this function, but you will need to implement the actual slicing in the doSlice function.
			 * \sa doSlice
			 */
			void slice(const QImage& image);
		protected:
			/**
			 * \brief Adds a piece to the puzzle scene.
			 * Internally, the piece is assigned a consecutive index (0 for the first piece, 1 for the second piece, and so on) which has to be used when defining relations between the pieces.
			 * \param image the visible image (may contain transparent areas to gain a non-rectangular piece shape)
			 * \param positionInImage the bounding box of the piece (or more precisely, the bounding box of the \a image, including any transparent areas!)
			 */
			void addPiece(const QImage& image, const QRectF& positionInImage);
			/**
			 * \brief Adds a neighbor relation between two pieces.
			 * \param piece1Id the index of the first piece (assigned by order of addPiece operations, starting at zero)
			 * \param piece2Id the index of the second piece
			 * \param positionDifference the difference between the positions of both pieces
			 * \see addPiece
			 */
			void addRelation(int piece1Id, int piece2Id, const QPointF& positionDifference);
			/**
			 * \brief Provides the slicing algorithm.
			 * This function splits a given image into pieces and defines relations between them. These pieces and relations are used to build the puzzle.
			 * \param image the image to be sliced
			 * \see addPiece
			 * \see addRelation
			 */
			virtual void doSlice(const QImage& image) = 0;
		Q_SIGNALS:
			/// \internal
			void pieceGenerated(const QImage& image, const QRectF& positionInImage, const QPointF& sceneBasePosition);
			/// \internal
			void relationGenerated(int piece1Id, int piece2Id, const QPointF& positionDifference);
		private:
			PatternPrivate* p;
	};
}

#endif // PALAPELI_PATTERN_H
